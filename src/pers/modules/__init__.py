# ##############################################################################
# The contents of this file are subject to the PyTis Public License Version    #
# 2.0 (the "License"); you may not use this file except in compliance with     #
# the License. You may obtain a copy of the License at                         #
#                                                                              #
#     http://www.PyTis.com/License/                                            #
#                                                                              #
#     Copyright (c) 2018 Josh Lee                                              #
#                                                                              #
# Software distributed under the License is distributed on an "AS IS" basis,   #
# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License     #
# for the specific language governing rights and limitations under the         #
# License.                                                                     #
#                                                                              #
# @auto-generated by the PyTis Copyright Tool on 02:54 04 Apr, 2018            #
############################################################################## #

import glob
import os, sys
from pprint import pprint
from cStringIO import StringIO as sio

sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__),'..')))

import pytis as PyTis
from pytis import odict as ODict

__all__ = ['main', 'ExchangeRate', 'Service', 'ServiceManager']

class ExchangeRate(object):
	_parent = None

class Service(PyTis.cldict):
	log = None
	_name = "generic_service"
	_parent = None

	
	@classmethod
	def name(cls):
		return cls._name

	def __init__(self, parent):
		self.name = self.nameB
		self._parent = parent
		self.log = self.parent.log
		#self.setup()

		self.log.debug("__init__ of Service '%s' from parent Service module " \
			"complete" % self.name)
			
	@property
	def parent(self):
		return self._parent
	
	@property
	def nameB(self):
		return self._name

	@classmethod
	def displayed_name(cls):
		return cls._name
		#return self.language.lookup(self.lang_key)
	display_name = displayed_name
	 
	'''
	@property
	def display_name(self):
		return self.displayed_name
	'''
	
	def setup(self):
		self.log.critical('running setup for %s' % self.name)
	
	def start(self):
		pass
	
	def run(self):
		pass


#class ServiceManager(PyTis.cldict, ODict):
class ServiceManager(ODict):

	log = None
	module_base_dir = None

	_services = {} # a dict of services (in the module directory) that contains 
		# their path, and name.  I'm still having trouble deciding if the instance
		# should be stored here, or in a separate dict...

	def __init__(self, module_base_dir=None, log=None):
		ODict.__init__(self)
		self._services = ODict()
		self.module_base_dir = module_base_dir
		self.log = log
		#self._initialized_services = {}
		# self.loadServices()

	@property
	def services(self):
		""" _services is an ordered dict, whereas services is a list of dicts
		"""
		return [v for v in self.getServices()]

	def getServices(self):
		""" returns list of dicts for iteration
		"""
		return [v for v in self._services.values()]	
			
	def getService(self, name):
		""" return a service, looked up by name
		"""
		return self._services[name]
		
	def __getitem__(self, key):
		if PyTis.is_int(key):
			try:
				return self[self.keys()[key]]
			except IndexError:
				raise KeyError("IndexError: list index out of range, converted to " \
					"KeyError, KEY: %s" % str(key))
		else:
			return ODict.__getitem__(self, key)

	def get_parent(self):
		return self._parent
	def set_parent(self, parent):
		self._parent = parent
	parent = property(get_parent, set_parent)
	
	def getNames(self):
		"""
		y = sio()	
		pprint(repr(self._services), y)

		self.log.error(y.getvalue())
		sys.exit()
		"""

		labels = [service.name for service in self.getServices()]
		labels.sort()
		return labels

	def importServices(self):
		for mod_name in self._services.keys():
			mod_filename = __import__(mod_name)
			obj = getattr(mod_filename,mod_name)
			#obj.log = self.log
			inst = obj(self)
			inst.path = self._services[mod_name].path

			self._services[mod_name] = inst

			self.log.debug('mod_filename: %s, dir %s' % (mod_name, 
				self.module_base_dir))

		return 0

	def scanModules(self):
		""" scan the module directory, and load them

		Time to define, exactly how this dictionary, and these dicts will work.
		I was having difficulty seperating two separate objects, one - being meta
		data about the classes (their names, paths, etc.), two - being the
		instantiated class objects.
		
		Lets try to combine them totally.

		"""
		# first, lets make sure we know the module directory, where it is, and that
		# it does indeed exist

		if not os.path.exists(self.module_base_dir):
			# We have a BIG problem, no modules directory.
			self.log.debug("Modules directory is missing!")
			self.log.debug("Modules directory path should be: %s" % \
				self.module_base_dir)
			sys.exit(1)
				
		# Now let's add it to the system path (only if it isn't already there).
		if self.module_base_dir not in sys.path:
			sys.path.insert(0,self.module_base_dir)

		mod_files=[f for f in glob.glob(os.path.join(self.module_base_dir,'*.py')) \
			# ignore the __init__.py file.
			if not os.path.basename(f).startswith('__')]

		mod_files.sort()
		# helps these be stored alphabetically.

		for mod_filename in mod_files:
			os.path.basename(mod_filename)[\
					:len(os.path.basename(mod_filename))-3]
			
			o = ODict()
			o['name'] = os.path.basename(mod_filename)[\
				:len(os.path.basename(mod_filename))-3]
			o['path'] = mod_filename
			
			self._services[o.name] = o


			mod_filename = __import__(o.name)
			obj = getattr(mod_filename, o.name)
			obj.path = mod_filename

			self.log.debug("ABOUT TO REGISTER INSTANCE")	
			#self.log.warn(obj.path)
			self._services[o.name]['obj'] = obj(self)

			self.__setitem__(o.name, o) 
			'''
			def __setitem__(self, key, item):
				UserDict.__setitem__(self, key, item)
				if key not in self._keys: self._keys.append(key)
			'''

			#self.log.warn(obj.path)
			self.log.debug("REGISTERED THE INSTANCE")	

		return 0

	# ###########################################################################
	# ###########################################################################
	# ###########################################################################
	# ###########################################################################
	# ###########################################################################
	# ###########################################################################
	# ###########################################################################
	# ###########################################################################


	def runServices(self):
		for service in self.services:
			service.run()
		
	def startService(self, dname):
		service = self.serviceByName(dname)
		if not service:
			raise UnknownServiceError, "Un-known Service: %s" % dname
		else:
			service.setup()
			service.start()
			
def other_main(log=None):
	# Made a singleton because of the NASTY sys.path and sys.module stuff
	# that was causing C Assertions.
	ServiceManager = ServiceManager(log)

def last_main():
	python_version=float("%s.%s"%(sys.version_info.major,sys.version_info.minor))
	print("This works in python version: %s" % python_version)

def main():
	python_version=float("%s.%s"%(sys.version_info.major,sys.version_info.minor))
	print("This works in python version: %s" % python_version)
	return 0

if __name__ == '__main__':
	sys.exit(main())

