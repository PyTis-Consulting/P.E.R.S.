# ##############################################################################
# The contents of this file are subject to the PyTis Public License Version    #
# 2.0 (the "License"); you may not use this file except in compliance with     #
# the License. You may obtain a copy of the License at                         #
#                                                                              #
#     http://www.PyTis.com/License/                                            #
#                                                                              #
#     Copyright (c) 2018 Josh Lee                                              #
#                                                                              #
# Software distributed under the License is distributed on an "AS IS" basis,   #
# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License     #
# for the specific language governing rights and limitations under the         #
# License.                                                                     #
#                                                                              #
# @auto-generated by the PyTis Copyright Tool on 02:54 04 Apr, 2018            #
############################################################################## #

import glob
import os, sys
from pprint import pprint
from cStringIO import StringIO as sio

sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__),'..')))

import pytis as PyTis
from pytis import odict as ODict

__all__ = ['main', 'ExchangeRate', 'Service', 'ServiceManager']

class ExchangeRate(object):
	_parent = None

class Service(PyTis.cldict):
	log = None
	name = "generic_service"
	_parent = None
	instanuated = 'False'

	def __init__(self, parent):
		self._parent = parent
		self.log = self.parent.log
		self.instanuated = 'True'
		#print dir(self)
		#self.setup()
		self.is_instantuated = self.is_instantuated2
		self.log.debug("__init__ of Service '%s' from parent Service module " \
			"complete" % self.name)
			

	@classmethod
	def dead(cls):
		return "dead"

	@property
	def alive(self):
		return ".alive"

	def is_instantuated2(self):
		print 'inst method'
		return self.instanuated

	@classmethod
	def is_instantuated(cls):
		print 'cls method'
		return cls.instanuated

	'''
	def get_name(self):
		return self._name
	name = property(get_name)
	'''

	"""
	@classmethod
	def name(cls):
		return cls._name
	"""
	
	@property
	def parent(self):
		return self._parent
	
	@classmethod
	def displayed_name(cls):
		return cls._name
		#return self.language.lookup(self.lang_key)
	display_name = displayed_name
	 
	'''
	@property
	def display_name(self):
		return self.displayed_name
	'''
	
	def setup(self):
		self.log.critical('running setup for %s' % self.name)
	
	def start(self):
		pass
	
	def run(self):
		pass

	"""
	def __getattribute__(self, key):
		print "__getattribute__|key: %s" % key
		if key == 'name':
			return PyTis.cldict.__getattribute__(self, '_%s' % key)
		return PyTis.cldict.__getattribute__(self, key)

	def __attr_get(self,key):
		print "__attr_get|key:%s" % key
		return PyTis.cldict.__attr_get(self, key)

	def __getattr__(self,key):
		print "__getattr__|key:%s" % key
		return PyTis.cldict.__getattr__(self, key)

	def __getitem__(self, key):
		print "__getitem__|key:%s" % key
		return PyTis.cldict.__getitem__(self, key)
	"""

#class ServiceManager(PyTis.cldict, ODict):
class ServiceManager(ODict):

	log = None
	module_base_dir = None

	_services = {} # a dict of services (in the module directory) that contains 
		# their path, and name.  I'm still having trouble deciding if the instance
		# should be stored here, or in a separate dict...

	def __init__(self, module_base_dir=None, log=None):
		ODict.__init__(self)
		self._services = ODict()
		self.module_base_dir = module_base_dir
		self.log = log
		#self._initialized_services = {}
		# self.loadServices()

	@property
	def services(self):
		""" _services is an ordered dict, whereas services is a list of dicts
		"""
		return [v for v in self.getServices()]

	def getServices(self):
		""" returns list of dicts for iteration
		"""
		return [v for v in self.values()]	
		# return [v for v in self._services.values()]	
			
	def getService(self, name):
		""" return a service, looked up by name
		"""
		return self._services[name]

	def __getitem__(self, key):
		if PyTis.is_int(key):
			try:
				return self[self.keys()[key]]
			except IndexError:
				raise KeyError("IndexError: list index out of range, converted to " \
					"KeyError, KEY: %s" % str(key))
		else:
			return ODict.__getitem__(self, key)

	def get_parent(self):
		return self._parent
	def set_parent(self, parent):
		self._parent = parent
	parent = property(get_parent, set_parent)
	
	def getNames(self):
		"""
		y = sio()	
		pprint(repr(self._services), y)

		self.log.error(y.getvalue())
		sys.exit()
		"""

		labels = [service.name for service in self.getServices()]
		labels.sort()
		return labels

	def initializeServices(self):
		log=self.log

		for mod_name in self._services.keys():
			log.fatal('mod name is: %s' % mod_name)
			mod_filename = __import__(mod_name)
			obj = getattr(mod_filename,mod_name)
			#obj.log = self.log
			inst = obj(self)
			inst.path = self._services[mod_name].path

			self._services[mod_name] = inst
			self.data[mod_name] = inst

			self.log.debug('mod_filename: %s, dir %s' % (mod_name, 
				self.module_base_dir))


		return 0

	def scanModules(self):
		""" scan the module directory, and load them

		Time to define, exactly how this dictionary, and these dicts will work.
		I was having difficulty seperating two separate objects, one - being meta
		data about the classes (their names, paths, etc.), two - being the
		instantiated class objects.
		
		Lets try to combine them totally.

		"""
		# first, lets make sure we know the module directory, where it is, and that
		# it does indeed exist
		log=self.log
		if not os.path.exists(self.module_base_dir):
			# We have a BIG problem, no modules directory.
			self.log.debug("Modules directory is missing!")
			self.log.debug("Modules directory path should be: %s" % \
				self.module_base_dir)
			# create it now?

			sys.exit(1)
				
		# Now let's add it to the system path (only if it isn't already there).
		if self.module_base_dir not in sys.path:
			sys.path.insert(0,self.module_base_dir)

		# ignore the __init__.py file.
		# ignore *.pyc files
		mod_files=[f for f in glob.glob(os.path.join(self.module_base_dir,'*.py')) \
			if not os.path.basename(f).startswith('__')]

		# helps these be stored alphabetically.
		mod_files.sort()

		for mod_filename in mod_files:
			name = os.path.basename(mod_filename)[\
					:len(os.path.basename(mod_filename))-3]

			self.log.debug("ABOUT TO REGISTER INSTANCE")	
			mod_file = __import__(name)
			obj = getattr(mod_file, name)
			obj.module = mod_file
			obj.path = mod_filename
			obj.filename = obj.basename = os.path.basename(mod_filename)
			obj.dirname = os.path.abspath(os.path.dirname(mod_filename))
			
			log.info("mod_filename: %s" % mod_filename)
			log.info("mod_file: %s\n" % mod_file)
			log.info("obj.module: %s" % obj.module)
			log.info("obj.path: %s" % obj.path)
			log.info("obj.name: %s" % obj.name)
			log.info("obj.basename: %s" % obj.basename)
			log.info("obj.filename: %s" % obj.filename)
			log.info("obj.dirname: %s\n\n\n" % obj.dirname)


			self.__setitem__(name, obj)
			self.log.debug("REGISTERED THE INSTANCE")	

		return 0

	# ###########################################################################
	# ###########################################################################
	# ###########################################################################
	# ###########################################################################
	# ###########################################################################
	# ###########################################################################
	# ###########################################################################
	# ###########################################################################


	def runServices(self):
		for service in self.services:
			service.run()
		
	def startService(self, dname):
		service = self.serviceByName(dname)
		if not service:
			raise UnknownServiceError, "Un-known Service: %s" % dname
		else:
			service.setup()
			service.start()
			
def other_main(log=None):
	# Made a singleton because of the NASTY sys.path and sys.module stuff
	# that was causing C Assertions.
	ServiceManager = ServiceManager(log)

def last_main():
	python_version=float("%s.%s"%(sys.version_info.major,sys.version_info.minor))
	print("This works in python version: %s" % python_version)

def main():
	python_version=float("%s.%s"%(sys.version_info.major,sys.version_info.minor))
	print("This works in python version: %s" % python_version)
	return 0

if __name__ == '__main__':
	sys.exit(main())

