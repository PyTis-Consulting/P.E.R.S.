#!/usr/bin/env python
# ##############################################################################
# The contents of this file are subject to the PyTis Public License Version    #
# 2.0 (the "License"); you may not use this file except in compliance with     #
# the License. You may obtain a copy of the License at                         #
#                                                                              #
#     http://www.PyTis.com/License/                                            #
#                                                                              #
#     Copyright (c) 2018 Josh Lee                                              #
#                                                                              #
# Software distributed under the License is distributed on an "AS IS" basis,   #
# WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License     #
# for the specific language governing rights and limitations under the         #
# License.                                                                     #
#                                                                              #
# @auto-generated by the PyTis Copyright Tool on 09:58 04 Apr, 2018            #
############################################################################## #
"""pers
====

NAME:
	pers

SYNOPSIS:
	pers [--options] [-H] [-V] [-D]

DESCRIPTION:

CODE:



UNDERSTANDING LOGGING and OUTPUT:

 The way my PyTis scripts and programs work, I hardly ever use the print
 command.  Instead I just log something using a custom logging class.  I have
 four log levels: debug, info, warn and error. Messages may or may not make it
 to the screen (as my logging class will print output as it logs) depending on
 which arguments you pass into the program you are executing.

 The current setup allows for 2 log files, to be written to the PyTis
 configured log directory.  If you do not use debug, then the log file used
 will be the pytis_tools.log, if debugging is turned on, then the log file will
 be {program_name}.log found in the same directory.  In this program's case
 that would be pybkup.log  So if you use -D the output ends up in a different
 log file, but this is just to keep debugging separate from normal logging.  -V
 --verbose is off by default by with this program, unless you use the action
 'test' then it is on (unless you specify --quiet, then it stays off).


 debug:
  Not to log-file or to screen by default, but if turned on with the -D or
    --debug flag, it will always end up in the debug log file (pybkup.log).

  -D: print debug messages to log only

  -V: alone does not print debug messages anywhere, because -D or --debug not
    given

  -DV: now debug messages are sent to their log file, and make it to the screen

 info:
  Print normal level information, always written to log (although which log is
    being used depends on if you are using debugging, as stated above).

  -V allows info messages to print to STDOUT, thus to the screen for you to
    see.

  -q or --quiet turns off -V


 warn:
  Warnings will always make it to which ever log is being used, and it will
    always make it to the screen unless -q is passed in.  If -q is passed in
    then warnings are hidden from STDOUT, thus only show in log files.

	-q suppresses warnings to STDOUT (the screen) but they will still end up in
		whichever log this program is using.

 error:
  error messages always make it to the screen, no matter what; and are always
    logged to the log file as well.

 Notes:
	To ensure there is no confusion, I want to specify that the log file is
		chosen one time during the first stages of the program firing up, it does
		not switch back and forth while running, nothing complex like that.  Simply
		this, all of my programs share pytis_tools.log unless they are in debug
		mode.  Then, since they are obviously going to spit out allot more
		information, they write to their very own log file for that run.  That way
		they don't fill up and clutter the shared pytis_tools.log

	'-DVq' confuses my little logging class.  -q silences most messages, nothing
		but errors make it to the screen, -D was passed in so the debug log is used
		(pybkup.log) however logging level is set to verbose, with nothing to the
		screen so what ends up happening is only info messages make it to the debug
		log (debug messages hidden).

DEPENDENCIES:

"""
default_pg_port=5432
# default_pg_host='127.0.0.1'
default_pg_host='192.168.1.8'

# ############################ DO NOT EDIT BELOW ############################ #
errors = []

# =============================================================================
# Begin Imports
# -----------------------------------------------------------------------------
# builtin
import datetime
import optparse
import os
import platform
from pprint import pprint
import sys
from cStringIO import StringIO

# This program needs to import PyTis(2) v4.1, which imports modules from the
# sub-package pylib, this program also needs to import from the sub-package
# cobj, pylib.cobj itself, has to import from the parent, pytis, which it
# can only do if the parent directory is a package, turning the parent (bin)
# into a package breaks importing pytis for this program in the first place
# and caused severe circular import errors.	To fix this, we have to adjust the
# path.
# vvvvv XXX-TODO may not need this here, dunno, remove at end and try it. vvvvv
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__),'..')))
# ^^^^^ XXX-TODO may not need this here, dunno, remove at end and try it. ^^^^^

#
# Internal
#
try:
	#from pers import	PyTis # Shared GPL/PPL License
	import pytis as PyTis # Shared GPL/PPL License
	from pylib import configobj as COBJ
	from modules import ServiceManager as ServiceManager
except ImportError as e:
	# We cannot go any further than this, we can't use the Parser or Logging tool
	# to display these errors because those very tools are loaded from PyTis.
	# Therefore, display errors now and exit with an errored exit code.
	print("This program requires the PyTis Python library to run.")
	print("You may download the PyTis library, or do an SVN checkout from:")
	print("<https://sourceforge.net/projects/pytis/>")
	print("This program should be installed in the bin directory of the PyTis library.")
	print(str(e))
	sys.exit(1)

is_debian = 'debian' in ' '.join(platform.dist()).lower() or 'ubuntu' in \
	' '.join(platform.dist()).lower()

#
# Third-Party
#
try:
	import pg
	from pg import InternalError
except ImportError as e:
	# it is ok not to use log here, in fact it is not even defined yet
	errors.append('Missing required package pg - PyGreSQL classic interface.')
	errors.append("This program requires python-pygresql.\n" \
	"PyGreSQL is a Python module that interfaces to a PostgreSQL database.\n" \
	"Please ask your administrator for assistance.")
	if is_debian:
		errors.append("Or, if you have administrative rights, you may run: \n" \
			"sudo apt-get install python-pygresql\n")
# =============================================================================
# End Imports
# -----------------------------------------------------------------------------


__author__ = 'Josh Lee'
__copyright__ = 'PyTis.com'
__created__ = '08:32pm 04 Mar, 2018'
__curdir__ = os.path.abspath(os.path.dirname(__file__))
__version__ = '0.1'


# =============================================================================
# Begin HELPER Functions
# -----------------------------------------------------------------------------
die=PyTis.die
def dbConn(opts):
	""" Standard db connection function.	They don't get any easier than this.
			This function takes a class dict, or in this case, opts from the option
			parser, then references the values by property name.
	"""

	try:
		conn = pg.connect(dbname=opts.db_database,
											user=opts.db_username,
											passwd=opts.db_password,
											host=opts.db_host,
											port=opts.db_port)

	except pg.InternalError as e:
		""" We need to clean up the message, in case it is -- 
					'FATAL:  password authentication failed for user "tip_u_cash"'
			because the message is duplicated due to an error in the python pg 
			package.
		"""
		lines = str(e).split("\n")
		old_len=len(lines)
		lines = [line.replace('FATAL:  ','') for line in lines]
		lines=PyTis.unique(lines)
		new_len = len(lines)

		if old_len == new_len:
			# no duplicates
			e = str(e).strip("\n").replace('FATAL:  ','')
		else:
			e = "\n".join(lines).strip("\n").replace('FATAL:  ','')

		raise PyTis.ConfigurationError(str(e))

	else:
		return conn


def testDbConn(conn):
	try:
		return conn.query("SELECT 1;")
	except pg.InternalError as e:
		raise PyTis.ConfigurationError(str(e))

def relogOpts(log, opts):
	""" After all config file loading, option parsing and data crunching	has
			been completed, ths function will re-log to debug all options gathered,
			so we	can see what their values are.
	"""

	# I want the output alphabatized, so I am going to create a list of tuples,
	# sort them, no wait, you know what would be faster? to just grab the keys,
	# sort those, request each value by key.
	log.debug('-'*80)
	opt_keys = list(opts.__dict__.keys())
	opt_keys.sort()

	for opt in opt_keys:

		value = opts.__dict__[opt]

		if type(value) == type(str('')):
			# for optional args)
			if value.strip() == '_empty_val_trick_':
				value = ''

		if 'password' in str(opt).lower():
			if value:
				value = '*'*96
			else:
				value = 'N/A'

		log.debug("OPTION %s: %s" % (opt,value))

	log.debug('-'*80)


# =============================================================================
# End HELPER Functions
# -----------------------------------------------------------------------------
class UnknownServiceError(Exception): pass
# =============================================================================
# Begin MAIN PROGRAM FUNCTION
# -----------------------------------------------------------------------------

class PersThread(PyTis.MyThread):
	"""
	I had to create a class, so that as a service, some of the options and their
	"Defaults" would not be lost.	I have a feeling this is what I had in mind
	when I first coded the MyThread, as I can tell from looking at it, it is
	meant to be subclassed.	It even has a nice stop method for me to override.
	Instead of making something from scratch, I am using the thread to share
	logging, opts, and default thread values, such as ioniceness.
	"""

	base_dir = ''

	def __init__(self, opts):
## XXX-TODO TODAY XXX XXX
		PyTis.MyThread.__init__(self)	
## XXX-TODO TODAY XXX XXX

		self.setOpts(opts)
		#self.log.pause()
		self.setup()

	def setup(self):
		self.base_dir=os.path.abspath(os.path.realpath(os.path.dirname(__file__)))
		if self.base_dir not in sys.path:
			sys.path.insert(0,self.base_dir)
		self.module_base_dir=os.path.abspath(os.path.join(self.base_dir,'modules'))
		#print("made it here."*100)

		self.setNiceness()

		self.SM=ServiceManager(self.module_base_dir, self.log)
		self.SM.scanModules()
		self.SM.initializeServices()

		#if self.opts.action == 'start' or self.opts.once:
	
		if not self.opts.list:
			try:
				conn = dbConn(self.opts)
			except PyTis.ConfigurationError as e:
				self.log.info('had errors??? :%s:' % str(bool(self.log.hadErrors)))
				self.log.error(str(e))
				self.log.info('had errors??? :%s:' % str(bool(self.log.hadErrors)))
			#	self.log.fatal(e, exc_info=1)
				return 1

			if not testDbConn(conn):
				raise PyTis.ConfigurationError('DB Conn UN-SUCCESSFULL')
			else:
				self.log.warn('DB Conn successfull')
				self.conn = conn


	@property
	def services(self):
		return self.SM.services
		return [v.obj for v in self.services]

	def serviceByNumber(self, number):
		self.log.debug("serviceByNumber")
		try:	
			reference =  int(number) - 1
		except:
			raise PyTis.InvalidInput("Invalid selection, you must choose 1 " \
				"through %s, you choose %s." % (len(self.services), str(repr(number))))

		if reference not in range(0,len(self.SM)):
			raise PyTis.InvalidInput("Invalid selection, you must choose 1 " \
				"through %s, you choose %s." % (len(self.services), str(repr(number))))

		if reference == -1:
			raise PyTis.InvalidInput("Invalid selection, you must choose 1 " \
				"through %s, you choose %s." % (len(self.services), str(repr(number))))

		try:
			retval = self.SM.values()[reference]
		except IndexError as ignore_error_text:
			raise PyTis.InvalidInput("Invalid selection, you must choose 1 " \
				"through %s, you choose %s." % (len(self.services), str(repr(number))))
		else:
			return retval
		
	def serviceByName(self, name):
		""" Return a service by name 
		"""
		self.log.debug("serviceByName")
		try:		  
			retval = self.SM[name]
		except KeyError as e:
			raise UnknownServiceError("Service not found: %s" % str(name))
		return retval
	
	def findService(self, name_or_number):
		if PyTis.is_int(name_or_number):
			return self.serviceByNumber(name_or_number)
		else:
			return self.serviceByName(name_or_number)

	def runOnce(self, which_one=None): 
		""" This is to run outside of threading, so that modules/services may print
				directly to the console.  You can pass a module reference from the
				argument [-L/--list] in, by name or the displayed number assigned and
				displayed when using the [-L/--list] argument.

		"""
		if which_one:
			try:
				service = self.findService(which_one)
			except PyTis.InvalidInput as e:
				self.log.error(str(e))
				return 1
			
			service = service(self)

			service.setup()

			service.run()

			return 0

		else:
			for service in self.SM.values():

				service.setup()

				service.run()

			self.log.error('done sir done')

			sys.exit()

		# self.run
		return 0

	def start(self):
		""" missleading in the fact that it could be named "pre-run", this will
		only run once per process (pid).
		"""
		self.log.error('override start')
		self.log.error('I RAN')
		return

	def run(self):
		"""pers run doc help"""
		global errors
		self.log.info('Running PERS as a threaded service.')

		for service in self.SM.getServices():
			service.start()
	
	def runServices(self):
		for service in self.SM.getServices():
			service.run()

		
	def startService(self, dname):
		service = self.serviceByName(dname)
		if not service:
			raise UnknownServiceError, "Un-known Service: %s" % dname
		else:
			service.setup()
			service.start()
# VOID

	def relogOpts(self):
		return relogOpts(self.log, self.opts)

def main():
	"""usage: pers [-a/--action] [-Dv] (example: pers start)
	"""
	global default_pg_host, default_pg_port, errors

	config_filename = os.path.abspath(os.path.join(PyTis.__configdir__, 
		'%s.ini' % os.path.basename(os.path.abspath(sys.argv[0]))))

	if not errors:
		# just a test, does it exist (it is okay if it doesn't, this may be the
		# first time it was ran.
		if not os.path.exists(config_filename):
			# OH noes, it doesn't
			# what about...
			try:
				# well, does it exist here?
				if os.path.exists(os.path.abspath(os.path.join(PyTis.__configdir__, 
					'config.ini'))):
					# it does?  yea! lets "set it."
					config_filename = os.path.abspath(os.path.join(PyTis.__configdir__, 
					'config.ini'))
				else:
					# it doesn't? well, that's okay, we have one other guess.
					# what about, does it exist here?
					if os.path.exists('/etc/pers.ini'):
						# it does?  yea! lets "set it."
						config_filename = '/etc/pers.ini'
					else:
						# it doesn't? well, that's okay, the default will work (this must be
						# the first time the program was ran).
						pass

			except (OSError, IOError) as forget:
				pass

		main.__doc__ = "%s\n\n	CONFIG FILE: %s" % (main.__doc__,
			os.path.abspath(config_filename))


	PyTis.__option_always__ = [True]
	help_dict = dict(version=__version__,
						 author=__author__,
						 created=__created__,
						 copyright=__copyright__)
	parser = PyTis.MyParser()

	parser.extra_txt = "\n\n%s\n" % PersThread.run.__doc__ + """

examples:	
	xxx

SEE ALSO:
	xxx

COPYRIGHT:
	%(copyright)s

AUTHOR:
	%(author)s

HISTORY:
	Original Author

VERSION:
	%(version)s
""" % help_dict

	parser.formatter.format_description = lambda s:s
	parser.set_description(__doc__)
	parser.set_usage(main.__doc__)

	if '--help' in sys.argv:
		parser.set_description(__doc__)
		helpishere=True # to determine help mode (short or full)

		action_help = "Another optional argument that does not require to be " \
			"prefixed (-a/--action) this can simply be typed out. `$`$" \
			"		i.e.: pers -DV -u start `$" \
			"This argument allows you to access the service features of this " \
			"program. Choices: <start, stop, restart, status>, when using the " \
			"[-b/--background] flag, this argument is not required, as the 'start'" \
			" action is automatically implied."

		background_help = "This could take hours to run, and you may wish to " \
			"run it from a CRON job.	When you get a chance, if you want to know " \
			"if it is done running, you can simply type in 'pers status' to " \
			"see if it is still running (if you used the [-b/--background] flag.`$" \
			"If this flag is used, the 'start' action is implied for the " \
			"[-a/--action] argument.`$"

		config_file_help = 'Although this program can generally auto-guess the ' \
			'path of its own config file (usually in ' \
			'/home/{USER}/etc/pers.ini) OR ' \
			'/root/etc/pers.ini), ' \
			'if it is located in a random, or unique location, you can specify ' \
			'that here with the [-c/--config-file] argument.	The configuration ' \
			'file must be in INI format.	This program may look to it to load the ' \
			'Database Settings.`$ (default: %s) `$' % config_filename

		config_test_help = "This feature is to help test what the options' " \
			"values were after they are finally loaded in; compiling all data " \
			"loaded/read from the config.ini file (or whichever INI file you " \
			"decide to pass in via the [-c/--config-file] argument), as well as " \
			"all of the flags passed in (which are usually boolean True/False) -- " \
			"(Flag based options take no additional input, whereas Argument based " \
			"options do).  After everything is loaded, decoded, and ready to go, " \
			"this feature will print it to the screen to show you what was loaded " \
			"in.  This is helpful for say if the DB isn't connecting.  Perhaps " \
			"the HOST IP is being loaded incorrectly.  I've personally created " \
			"this, for debugging, and have found it a very useful feature.`$"

		debug_help = "Enable debugging.	When debugging is enabled, this " \
			"program will utilize it's own log file ('pers.log') logging will " \
			"write to the ('pytis-tools.log') when this option is NOT enabled.	" \
			"When utilizing the [-D/--debug] flag, debug statements will " \
			"also print to the screen, unless you suppress them with the " \
			"[-q/--quiet] flag.`$"


		db_username_help = 'To specify the database username, or override one ' \
			"saved in this program's	config file, use the [-U/--username] " \
			"argument.`$"

		db_password_help = 'To specify the database password, or override one ' \
			"saved in this program's	config file, use the [-P/--password] " \
			"argument.	Please note, if you intend to save the password in the " \
			"INI file, you must first encode it with the [-e/--encode-password] " \
			"argument.	Plain text passwords will not work.`$"

		db_database_help = 'To specify a database name, or override one saved ' \
			"in this program's	config file, use the [-d/--database] argument.`$"

		db_host_help = 'To specify the database host name, or override one ' \
			"saved in this program's	config file, use the [-H/--hostname] " \
			"argument. `$(default: %s)`$" % default_pg_host

		db_port_help = 'To specify the database port, or override one saved ' \
			"in this program's	config file, use the [-p/--port] argument. `$" \
			"(default: %s)`$" % default_pg_port

		db_limit_help = 'NOT USED YET, I DO NOT KNOW WHAT HELP INFO TO TYPE ' \
			'BECAUSE THIS IS NOT YET USED.' \
			'To specify a database query limit, or override one ' \
			"saved in this program's	config file, use the [--LIMIT]. This " \
			"optional argument is used twice, once to pass a limit to the " \
			"PERS (Python Exchange Rate Scanner/Service), limiting the " \
			"number of.. NOT USED " \
			".`$"

		encode_password_help = 'Utilizing this feature will print out an ' \
			'encoded password for your config file, so that you can save it ' \
			'encrypted, and this program will still be able to read it.	Run the ' \
			'program, calling this flag, and passing in your password on the ' \
			'command line, it will print out the encoded password to be saved to ' \
			'your pers.ini file. `$`$' \
			'Remember, the password can still be overridden utilizing the ' \
			'[-P/--password] argument.`$'

	else:
		helpishere=False # to determine help mode (short or full)
		parser.set_description('')

		action_help = "Access the service features of this program. `$" \
			"Choices: <start, stop, restart, status>`$" \
			'*(use "--help" for more details)`$'

		background_help = "Background this process as a service. `$" \
			'`$*(use "--help" for more details)`$'

		config_file_help = 'Path for pers.ini (default: ' \
			'/root/etc/pers.ini).	*(use "--help" for more details)`$'

		config_test_help = 'Prints to screen all options (arguments and flags' \
			'without doing anything else.	*(use "--help" for more details)`$'

		debug_help = "Enable debugging`$" \
			'`$*(use "--help" for more details)`$'

		db_username_help = 'To specify a CS Portal Database username, use the ' \
			'[-U/--user] argument. `$' \
			'*(use "--help" for more details)`$'

		db_password_help = 'To specify a CS Portal Database password, use the ' \
			'[-P/--password] argument.`$'\
			'*(use "--help" for more details)`$'

		db_database_help = 'To specify the CS Portal Database name, use the ' \
			"[-d/--database] argument.`$" \
			'*(use "--help" for more details)`$'

		db_host_help = 'To specify a CS Portal Database host name, use the ' \
			'[-H/--hostname] argument. (default: %s)`$' \
			'*(use "--help" for more details)`$' % default_pg_host

		db_port_help = 'To specify a CS Portal Database port, use the ' \
			'[-p/--port] argument.	(default: %s)`$' \
			'*(use "--help" for more details)`$' % default_pg_port

		db_limit_help = 'To specify a CS Portal Database limit, use the ' \
			'[--limit] argument.`$'\
			'*(use "--help" for more details)`$'

		encode_password_help = 'Generate an encoded password for the ini ' \
			'configuration file, an added security feature so the database ' \
			'password is not stored in plain text.`$' \
			'*(use "--help" for more details)`$'

  # ------------------------------------------------------------------------ |
	# -------------------------------------------------------------------------
	# runtime variable setting
  # ------------------------------------------------------------------------ |
	runtime = optparse.OptionGroup(parser, "-- RUNTIME ARGUMENTS")
	# ----------------------------

	runtime.add_option("-a", "--action", type="choice", action='store',
		default=None, dest='action', choices=['start','stop','restart','status'],
		metavar='[ACTION]',
		help=action_help)

	runtime.add_option("-b", "--background", action="store_true",
		default=False, dest='background',
		help=background_help)

	runtime.add_option("-L", "--list", action="store_true",
		default=False, dest='list',
		help="List the modules that are loaded.`$")

	runtime.add_option("-n", "--name", action="store",
		default=None, dest='named',
		help="Run a particular module by name (or number) use [-L/--list] to " \
			"get a list of the available module names (and corresponding " \
			"numbers).`$")

	runtime.add_option("-o", "--run-once", action="store_true",
		default=False, dest='once',
		help="Run all or the modules just once.`$")

	parser.add_option_group(runtime)
  # ------------------------------------------------------------------------ |
	# -------------------------------------------------------------------------
	# configuration variable setting
  # ------------------------------------------------------------------------ |
	vars = optparse.OptionGroup(parser, "-- CONFIGURATION SETTINGS")
	# ----------------------------

	vars.add_option("-c", "--config-file", action="store", type="string",
		default=config_filename, metavar='[PATH]', dest='config_filename',
		help=config_file_help)

	vars.add_option("-e", "--encode-password", action="store", type="string",
		default=None, metavar='[PASSWORD]', dest='encode_password',
		help=encode_password_help)

	# ----------------------------
	# ----------------------------
	vars.add_option("-i", "--ionice", type="int", action='store',
		 default=PyTis.MyThread.default_ioniceness, 
		 dest='ioniceness',
		 metavar='[INT <0 to 7>]',
		 help="Niceness range from 0 " \
					"(most favorable scheduling) to 7 (least favorable).	Default 4.`$" \
					"for more information, please run: man ionice.`$")

	vars.add_option("-I", "--io-class", type="int", action='store',
		default=PyTis.MyThread.default_ioniceness_class, 
		dest='ioniceness_class',
		metavar='[INT <0-3>]',
		help="The scheduling class. 0 for none, 1 for real time, 2 for " \
			"best-effort, 3 for idle. Default: 2`$")

	# ----------------------------

	vars.add_option("-N", "--nice", type="int", action='store',
		 default=PyTis.MyThread.default_niceness, 
		 dest='niceness', 
		 metavar='[INT <-20 to 19>]',
		 help="Niceness range from -20 (most favorable scheduling) to 19 " \
		 "(least favorable).	Default 10.`$" \
		 "for more information, please run: man nice.`$")
	# ----------------------------
	# ----------------------------

	vars.add_option("-t", "--time", type="int", action='store', default=0,
		dest='frequency', metavar='[INT]',
		 help="Frequency of how often the loop runs, how long (in minutes) to " \
			"sleep before re-running registered command (default is 1).`$")
		 #help=optparse.SUPPRESS_HELP)

	parser.add_option_group(vars)


  # ------------------------------------------------------------------------ |
	# -------------------------------------------------------------------------
	# db variable setting
  # ------------------------------------------------------------------------ |
	dbvars = optparse.OptionGroup(parser, "-- DATABASE SETTINGS", ' ')
	# ----------------------------

	dbvars.add_option("-U", "--user", action="store", type="string",
		default='', metavar='[USERNAME]', dest='db_username',
		help=db_username_help)

	dbvars.add_option("-P", "--password", action="store", type="string",
		default='', metavar='[PASSWORD]', dest='db_password',
		help=db_password_help)

	dbvars.add_option("", "--limit", action="store", type="int",
		default=-1, metavar='[LIMIT]', dest='db_limit',
		help=db_limit_help)

	dbvars.add_option("-p", "--port", action="store", type="int",
		default=default_pg_port, dest='db_port', metavar='[PORT]',
		help=db_port_help)

	dbvars.add_option('-H', "--hostname", action="store", type="string",
		default=default_pg_host, metavar='[HOSTNAME]', dest='db_host',
		help=db_host_help)

	dbvars.add_option('-d', "--database", action="store", type="string",
		default='', metavar='[DATABASE]', dest='db_database',
		help=db_database_help)

	parser.add_option_group(dbvars)
  # ------------------------------------------------------------------------ |
	# -------------------------------------------------------------------------
	# debug variable setting
	# -------------------------------------------------------------------------
	dbgroup = optparse.OptionGroup(parser, "-- DEBUG")
	# ----------------------------

	dbgroup.add_option("-C", "--config-test", action="store_true",
		default=False, dest='config_test',
		help=config_test_help)
	
	dbgroup.add_option("-D", "--debug", action="store_true",
					 default=False, dest='debug',
					 help="Enable debugging`$")

	dbgroup.add_option("-v", "--verbose", action="store_true",
					 default=False, dest='verbose',
					 help="Be more Verbose (make lots of noise)`$")

	dbgroup.add_option("-q", "--quiet", action="store_true",
					 default=False, dest='quiet',
					 help="be vewwy quiet (I'm hunting wabbits)`$")

	dbgroup.add_option("-V", "--version", action="store_true",
					 default=False, dest='version',
					 help="Display Version`$")

	# This is a little trick to tell if the user entered the -V/--verbose flag.
	# We want verbosity on by default, but we also want to know if the user
	# entered it for debug items, and providing end messages vs informed output.
	dbgroup.add_option("", "--totaly-verbose", action="store_true",
		default=False, dest='totally_verbose', 
		help=optparse.SUPPRESS_HELP)
	# ----------------------------
	parser.add_option_group(dbgroup)
	# ----------------------------

	(opts, args) = parser.parse_args()

	
	if opts.verbose: 
		opts.totally_verbose = True

	if opts.quiet: 
		opts.verbose = False

	if not opts.action and len(args) == 1 and \
		str(args[0]).lower().strip() == 'test':
		opts.config_test = True

	if opts.config_test:
		opts.debug=True
		opts.verbose=True
		opts.totally_verbose = True

	# ----------------------------

	old_version = opts.version
	opts.version = True

	if opts.list:	opts.verbose = True
	log = PyTis.set_logging(opts, os.path.basename(sys.argv[0]))
	
	opts.version = old_version

	if opts.version:
		return PyTis.version(__version__)

	# ----------------------------

	if opts.encode_password:
		if not opts.encode_password.strip():
			parser.print_usage()
			log.error("The password may not be an empty string.")
			return 1
		else:
			print PyTis.simpleEncode(opts.encode_password)
			return 0

	# ----------------------------

	if not errors:

		config_abs_path = os.path.abspath(opts.config_filename)
		if not os.path.exists(config_abs_path):
			try:
				PyTis.touch(config_abs_path)
#			Python 2.x does not have PermissionError(s) this did not come out until
#			Python3.0 
#			except PermissionError as e:
#				errors.append(str(e))
#				raise PyTis.FileNotFound("The Config INI file is missing, and we " \
#					"cannot create it, permission denied (%s)." % config_abs_path)
			except (IOError, OSError) as e:
				errors.append(str(e))
				raise PyTis.FileNotFound("The Config INI file is missing, and we " \
					"cannot create it (%s).  An unknown error has " \
					"occured." % config_abs_path)
		log.debug("ABS PATH of config file: %s" % config_abs_path)

	if not errors:

		#
		# load from config, anything not provided on the command line.
		#
		try:
			config = COBJ.load(config_abs_path)
		except (IOError, OSError) as e:
			errors.append("Cannot load the config file, for unknown reasons." \
				"\n%s" % str(e))

	if not errors:

		if not opts.frequency and opts.frequency != 0: # strip():
			opts.frequency = config.get('frequency',opts.frequency)
			log.fatal(opts.frequency)

		log.fatal(opts.frequency)
		die(opts.frequency)

		if not opts.db_username.strip():
			opts.db_username = config.get('db_username',opts.db_username)

		if not opts.db_host.strip() or opts.db_host == default_pg_host:
			opts.db_host = config.get('db_host',default_pg_host)

		if not str(opts.db_port).strip() or opts.db_port == default_pg_port:
			opts.db_port = config.get('db_port',default_pg_port)

		if not opts.db_database.strip():
			opts.db_database = config.get('db_database',opts.db_database)

		""" "proof" of concept
			>>> a = 'abcdef'
			>>> b = a.encode('ascii')
			>>> c = b64.b64encode(.strip()b)
			>>> d = b64.b64decode(c)
			>>> e = d.decode('ascii')
		"""
		# Treat the password a little differently, as we don't store it
		# plain-text, we store it base64encoded, simple, but at least then not
		# plain-text.
		if opts.db_password is not None and opts.db_password.strip():
			opts.db_password = opts.db_password.strip()
		else:
			encoded_txt = config.get('db_password',None)
			if(encoded_txt is None):
				errors.append("No DB Password was provided.")
			else:
				try:
					opts.db_password = PyTis.simpleDecode(encoded_txt)

				except PyTis.InputError as e:
					if opts.config_test:
						print("\n")
						log.warn('\tDB Conn UN-SUCCESSFULL')
						log.error("\t\tInvalid password format.\n\n%s"%PyTis.to80(str(e)))
						return 0
					else:
						log.error(str(e))
						raise PyTis.InvalidInput("Invalid input supplied for the " \
							"Database Password.  This string cannot be decoded (it must " \
							"be corrupt).")
				except UnicodeDecodeError as e:
					raise PyTis.InvalidInput("Invalid input supplied for the " \
						"Database Password.  This string cannot be decoded (it must " \
						"be corrupt).")

		if not opts.db_username:
			errors.append("No DB Username was provided.")
		if not opts.db_password:
			errors.append("No DB Password was provided.")
		if not opts.db_host:
			errors.append("No DB Host was provided.")
		if not opts.db_port:
			errors.append("No DB Port was provided.")
		if not opts.db_database:
			errors.append("No Database Name was provided.")

		if opts.background and not opts.action:
			opts.action='start'

		if not opts.action and len(args) == 1 and \
			str(args[0]).lower().strip() == 'test':
			opts.config_test = True

		if opts.action and len(args) == 1 and str(args[0]).lower().strip() \
			in ('start','stop','restart','status') and opts.action == args[0]:
			log.warn("Silly human, you provided an action via a flag (%s) " \
				"and the same option on STDIN (%s).	Remember, you only need to " \
				"provide the action once.." % (opts.action, args[0]))
			return 0

		if opts.action and len(args) == 1 and str(args[0]).lower().strip() \
			in ('start','stop','restart','status') and opts.action != args[0]:
			#errors.append("Silly human, you provided an action via a flag (%s) " \
			log.error("Silly human, you provided an action via a flag (%s) " \
				"and an option on STDIN (%s) and they are different.	Please only " \
				"provide one action." % (opts.action, args[0]))
			return 1

		if opts.action is None and len(args) and args[0] in \
			('start','stop','restart','status'):
			# action not provided as an attribute, but on STDIN, set opts.action now
			opts.action = args[0]
			# then we can remove it from args, no longer needed now that it is set in
			# opts.action
			del args[0]
	

	if not errors and opts.config_test:
		log.debug("* VALUES AFTER LOADING *")

		relogOpts(log, opts)

		try:
			conn = dbConn(opts)
		except PyTis.ConfigurationError as e:
			log.warn('DB Conn UN-SUCCESSFULL')
			log.error(PyTis.to80(str(e)), exc_info=0)
		except PyTis.InputError as e:
			log.warn('DB Conn UN-SUCCESSFULL')
			log.error("Invalid password format.\n%s" % PyTis.to80(str(e)))
		else:
			if testDbConn(conn):
				log.info('DB Conn successfull')
			else:
				log.critical('DB Conn UN-SUCCESSFULL')
		return 0



	if not errors:
		y = PersThread(opts)
		y.setLogFile(log)
		#y.setOpts(opts) # now done in the __init__ that was overridden.
		#y.register(y.relogOpts)
		#y.base_dir = os.path.abspath(os.path.realpath(os.path.dirname(__file__)))
		# print(y.base_dir)
	

	if not errors and opts.list:
		"""
		list_of_names = y.SM.getNames()

		how_many_names = len(list_of_names)
		# same as
		how_many_names = len(y.SM.getNames())

		number_to_string = str(how_many_names)
		# same as
		number_to_string = str(len(y.SM.getNames())) 

		how_many_charecters_in_number = len(number_to_string)
		# same as
		how_many_charecters_in_number = len(str(len(y.SM.getNames()))) 

		add_one_for_period ( how_many_charecters_in_number + 1) 
		# same as
		add_one_for_period ( len(str(len(y.SM.getNames()))) + 1) 

		# so....
		ljust = add_one_for_period
		"""

		#y = PersThread(opts)
		#y.setLogFile(log)
		ljust = len(str(len(y.SM.getNames()))) + 1

		print("\n* MODULES AVAILABLE *\n")
		for i,sname in enumerate(y.SM.getNames()):
			print("\t%s %s" % (str("%s." % str(i+1)).ljust(ljust), sname))
		return 0


	if not errors:
		try:
			os.nice(opts.niceness)
		except (AttributeError, NameError), e:
			pass



	if not errors and (opts.once or opts.named):
		return y.runOnce(opts.named)

	if not errors and opts.action:
		y.register(y.run)
		y.service(opts)
		print 'service called'
		return

	if len(args) == 0 and not errors and not opts.action:
		return parser.print_usage()
	elif not errors:
		# XXX-TODO finish FROM HERE ....
		try:
			y.Start()
			y.start()
			y.run()
		except KeyboardInterrupt,e:
			log.debug("Keyboard-Interrupt, bye!")
			if not opts.quiet:
				log.info("\nbye!")
			return
		else:
			log.info("Done.")
			return
		# XXX-TODO ... TO HERE 
	else:
		parser.print_usage()
		if errors:
			log.error(str("\n".join(errors)))
			return 1
		return parser.print_help(errors)

	parser.print_help("ERROR: Unknown, but invalid input.")
	sys.exit(0)

if __name__ == '__main__':
	try:
		sys.exit(main())
	except (PyTis.InvalidInput, PyTis.FileNotFound, UnknownServiceError) as e:
		sys.stderr.write("\nERROR: %s\n" % str(e))
		sys.exit(1)
	except PyTis.ConfigurationError as e:
		print(str(e))
		pass
		#sys.stderr.write("\nHEY YOU %s" % str(e))
		sys.exit(1)
		


